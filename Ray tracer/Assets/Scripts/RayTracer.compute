#pragma kernel TraceRays // 0

#include "MathResourcesRT.hlsl"

static const int ThreadsNum = 32;

// Constants
const int SpheresNum;

// View settings
const int2 Resolution;
const int MaxBounceCount;
const float viewSpaceWidth;
const float viewSpaceHeight;

// Camera orientation
const float3 WorldSpaceCameraPos;
const float3 CameraRotation;

struct Ray
{
    float3 origin;
    float3 dir;
};

struct Sphere
{
    float3 position;
    float radius;
};

struct HitInfo
{
    bool didHit;
    float dst;
    float3 hitPoint;
    float3 normal;
};

struct TraceInfo
{
    float3 rgbVal;
};

RWStructuredBuffer<Sphere> Spheres;

RWTexture2D<float4> Result;

float3 ApplyCameraTransform (float3 point_)
{
    float3x3 rotationX = float3x3(
        1, 0, 0,
        0, cos(CameraRotation.x), -sin(CameraRotation.x),
        0, sin(CameraRotation.x), cos(CameraRotation.x)
    );
    float3x3 rotationY = float3x3(
        cos(CameraRotation.y), 0, sin(CameraRotation.y),
        0, 1, 0,
        -sin(CameraRotation.y), 0, cos(CameraRotation.y)
    );
    float3x3 rotationZ = float3x3(
        cos(CameraRotation.z), -sin(CameraRotation.z), 0,
        sin(CameraRotation.z), cos(CameraRotation.z), 0,
        0, 0, 1
    );

    // Apply rotations in the order of Z, X, Y
    // Applying the rotation matrices in the order of Z, Y, X, results in issues when rotating around the x axis (don't know why)
    point_ = mul(rotationZ, point_);
    point_ = mul(rotationX, point_);
    point_ = mul(rotationY, point_);

    return point_;
}

HitInfo CircleRayIntersect (Ray ray, Sphere sphere)
{
    HitInfo hitInfo;
    hitInfo.didHit = false;

    // From the equation: sqrLength(rayOrigin + rayDir * dst) = radius^2
    // Solving for dst results in a quadratic equation with coefficients:
    float3 oc = ray.origin - sphere.position;
    float a = dot(ray.dir, ray.dir);
    float b = 2.0 * dot(oc, ray.dir);
    float c = dot(oc, oc) - sqr(sphere.radius);
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant > 0)
    {
        hitInfo.didHit = true;
        hitInfo.dst = (-b - sqrt(discriminant)) / (2.0 * a);
        hitInfo.hitPoint = ray.origin + hitInfo.dst * ray.dir;
        hitInfo.normal = normalize(hitInfo.hitPoint - sphere.position);
    }

    return hitInfo;
}

TraceInfo Trace (Ray ray, int maxBounceCount)
{
    TraceInfo traceInfo;
    traceInfo.rgbVal = float3(1, 1, 1);

    return traceInfo;
}

[numthreads(ThreadsNum,ThreadsNum,1)]
void TraceRays (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) { return; }

    // Calculate local ray start position
    float rayPosLocalX = (float(id.x) / Resolution.x - 0.5) * 2.0 * viewSpaceWidth;
    float rayPosLocalY = (float(id.y) / Resolution.y - 0.5) * 2.0 * viewSpaceHeight;
    float3 rayPosLocalOffset = float3(rayPosLocalX, rayPosLocalY, -1.0); // PlaneOffset must be positive

    // Transform ray position from local space to world space
    float3 rayPosWorld = ApplyCameraTransform(rayPosLocalOffset) + WorldSpaceCameraPos;

    // Calculate ray direction
    float3 rayDirLocal = normalize(rayPosLocalOffset);
    float3 rayDirWorld = normalize(ApplyCameraTransform(rayDirLocal)); // Transform to world space

    // Set ray values
    Ray startRay;
    startRay.origin = WorldSpaceCameraPos;
    startRay.dir = rayDirWorld;

    // Trace the ray through the scene
    for (int i = 0; i < SpheresNum; i++)
    {
        // first ray collision
        HitInfo hitInfo = CircleRayIntersect(startRay, Spheres[i]);
        if (hitInfo.didHit)
        {
            // Only render ray hits in front of the camera
            if (0 < dot(startRay.dir, float3(hitInfo.hitPoint - WorldSpaceCameraPos)))
            {
                // Trace ray further through the scene
                Ray secondRay;
                secondRay = startRay;
                TraceInfo traceInfo = Trace(secondRay, MaxBounceCount - 1);

                Result[id.xy] = float4(traceInfo.rgbVal.x, traceInfo.rgbVal.y, traceInfo.rgbVal.z, 0);
                return;
            }
        }
    }

    // Return default background color (no ray hit in front of camera)
    Result[id.xy] = float4(0, 0, 0, 0);
}
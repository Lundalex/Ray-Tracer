// #pragma kernel InitialTrace // 0
// #pragma kernel SpatialReusePass // 1
// #pragma kernel TransferToOriginal // 2
// #pragma kernel TemporalReuse // 3
// #pragma kernel TraceRays // 4

// #pragma multi_compile _ VIS_REUSE
// #pragma multi_compile _ WEIGHT_RECALC

// #include "RendererResources.hlsl"
 
// // Constants
// const uint TrianglesNum;
// const uint BVsNum;
// const uint MaxBVHDepth;
// const uint SceneBVHStartIndex;
// const uint SceneObjectsNum;
// const float ScatterProbability;
 
// // Render quality settings
// const uint MaxBounceCount;
 
// // View settings
// const int2 Resolution;
// const float2 ViewSpaceDims;
// const float DefocusStrength;
// const float FocalPlaneFactor;
 
// // Camera orientation and transform
// const float3 WorldSpaceCameraPos;
// const float3 LastWorldSpaceCameraPos;
// const float3x3 CameraTransform;
// const float3x3 LastCameraTransformInverse;
 
// // Per frame
// const uint FrameRand; // "random" value from 0 to 999999, gets reset each frame
// const uint FrameCount; // Each frame: FrameCount++
 
// // Debug
// const int2 DebugDataMaxValues;
 
// // ReSTIR - Reservoir sample quality
// const uint SceneObjectReservoirTestsNum;
// const uint TriReservoirTestsNum;
 
// // ReSTIR - Spatial reuse
// const bool ReuseBufferCycle;
// const int MaxOffset;
// const uint TemporalCandidatesNum;
// const float SpatialHitPointDiffThreshold;
// const float SpatialNormalsAngleThreshold;
 
// // ReSTIR - Temporal reuse
// const float TemporalReuseWeight;
// const float PixelMovementThreshold;
// const float TemporalPrecisionThreshold;

// // ReSTIR - Visibility reuse
// const float VisibilityReuseThreshold;

// // ReSTIR - Other
// const uint EmittingObjectsNum;
// const float TotArea;
 
// RWStructuredBuffer<HitInfo> HitInfos;
// RWStructuredBuffer<CandidateReservoir> Candidates; // float4(dir, weight)
// RWStructuredBuffer<CandidateReservoir> CandidatesB; // buffer double to "Candidates". Used for spatio-temporal reuse
// RWStructuredBuffer<CandidateReservoir> TemporalFrameBuffer;

// StructuredBuffer<BV> BVs;
// StructuredBuffer<SceneObject> SceneObjects;
// StructuredBuffer<LightObject> LightObjects;
// StructuredBuffer<Material2> Materials;

// StructuredBuffer<Triangle> Triangles;
// StructuredBuffer<Vertex2> Vertices;
 
// // RW textures
// RWTexture2D<float4> Result;
// RWTexture2D<float> DepthBuffer;
// RWTexture2D<float3> NormalsBuffer;
// RWTexture2D<float4> DebugOverlay;
// RWTexture2D<float3> RayHitPointsA; // double buffer A
// RWTexture2D<float3> RayHitPointsB; // double buffer B

// Texture2D<float4> TextureAtlas;
// Texture2D<float4> EnvironmentMap; // float4(r, g, b, brightness)
// const float2 TextureAtlasDims;
// const float2 EnvironmentMapTexDims;

// float3 SampleTexture(float2 uv, uint2 texLoc, uint2 texDims, Texture2D tex)
// {
//     uint2 texelCoord = texLoc + (uint2)(uv * float2(texDims.x, texDims.y));
//     float4 col = tex.Load(int3(texelCoord, 0));
 
//     return col.xyz;
// }

// float3 SampleEnvironmentMap(float3 dir)
// {
//     dir = -dir;

//     // Compute spherical coordinates
//     float theta = atan2(dir.z, dir.x); // longitude
//     float phi = asin(dir.y);           // latitude
    
//     float u = (theta / (2.0 * PI)) + 0.5;
//     float v = 0.5 - (phi / PI);
//     float2 uv = float2(u, v);

//     float3 col = SampleTexture(uv, int2(0, 0), EnvironmentMapTexDims, EnvironmentMap);

//     return col;
// }
 
// TriHitInfo RayTriangleIntersect(Ray ray, Triangle tri)
// {
//     Vertex2 v0 = Vertices[tri.vertex0Index];
//     Vertex2 v1 = Vertices[tri.vertex1Index];
//     Vertex2 v2 = Vertices[tri.vertex2Index];

//     float3 edgeAB = v1.pos - v0.pos;
//     float3 edgeAC = v2.pos - v0.pos;
//     float3 normalVector = cross(edgeAB, edgeAC);
//     float3 ao = ray.pos - v0.pos;
//     float3 dao = cross(ao, ray.dir);
 
//     float determinant = -dot(ray.dir, normalVector);
//     float invDet = 1 / determinant;
 
//     // Calculate dst to tri & barycentric coordinates of intersection point
//     float dst = dot(ao, normalVector) * invDet;
//     float u = dot(edgeAC, dao) * invDet;
//     float v = -dot(edgeAB, dao) * invDet;
//     float w = 1 - u - v;
 
//     // Initialize tri hit info
//     TriHitInfo triHitInfo;
//     triHitInfo.didHit = determinant >= 1E-8 && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
//     triHitInfo.uv = triHitInfo.didHit ? v0.uv * w + v1.uv * u + v2.uv * v : float2(0, 0);
//     triHitInfo.dst = dst;
//     return triHitInfo;
// }
 
// float RayBVIntersect(Ray ray, BV bv)
// {
//     float3 tMin = (bv.min - ray.pos) * ray.invDir;
//     float3 tMax = (bv.max - ray.pos) * ray.invDir;
//     float3 t1 = min(tMin, tMax);
//     float3 t2 = max(tMin, tMax);
//     float tNear = max(max(t1.x, t1.y), t1.z);
//     float tFar = min(min(t2.x, t2.y), t2.z);
 
//     bool didHit = tFar >= tNear && tFar > 0;
//     float dst = didHit ? tNear > 0 ? tNear : 0 : 1.#INF;
 
//     return dst;
// };
 
// void TraverseTrisBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray, uint bvStartIndex)
// {
//     uint bvStack[MAX_BVH_DEPTH + 1];
//     uint stackPointer = 0;
//     bvStack[stackPointer++] = bvStartIndex;
 
//     while (stackPointer > 0)
//     {
//         BV bv = BVs[bvStack[--stackPointer]];
 
//         bool isLeaf = bv.indexA >= 0;
//         bv.indexA = abs(bv.indexA);
//         bv.indexB = abs(bv.indexB);
        
//         if (isLeaf)
//         {
//             for (int triIndex = bv.indexA; triIndex < bv.indexA + bv.indexB; triIndex++)
//             {
//                 Triangle tri = Triangles[triIndex];
//                 if (dot(tri.localNormal, ray.dir) <= 0)
//                 {
//                     TriHitInfo triHitInfo = RayTriangleIntersect(ray, tri); debugData.triChecks++;
                
//                     if (triHitInfo.didHit && triHitInfo.dst < hitInfo.dst)
//                     {
//                         hitInfo.dst = triHitInfo.dst;
//                         hitInfo.uv = triHitInfo.uv;
//                         hitInfo.normal = tri.localNormal;
//                     }
//                 }
//             }
//         }
//         else
//         {
//             // Check child BV intersections
//             BV bvA = BVs[bv.indexA];
//             BV bvB = BVs[bv.indexB];
//             float dstA = RayBVIntersect(ray, bvA);
//             float dstB = RayBVIntersect(ray, bvB);
//             debugData.bvChecks += 2;
 
//             // Push the nearest BV last, to avaluate it first
//             if (dstA < dstB)
//             {
//                 if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
//                 if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
//             }
//             else
//             {
//                 if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
//                 if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
//             }
//         }
//     }
// }
 
// void TraverseSceneBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray)
// {
//     uint bvStack[MAX_BVH_DEPTH + 1];
//     uint stackPointer = 0;
//     bvStack[stackPointer++] = SceneBVHStartIndex;
 
//     while (stackPointer > 0)
//     {
//         BV bv = BVs[bvStack[--stackPointer]];
 
//         bool isLeaf = bv.indexA >= 0;
//         bv.indexA = abs(bv.indexA);
//         bv.indexB = abs(bv.indexB);
        
//         if (isLeaf)
//         {
//             for (int sceneObjectIndex = bv.indexA; sceneObjectIndex < bv.indexA + bv.indexB; sceneObjectIndex++)
//             {
//                 SceneObject sceneObject = SceneObjects[sceneObjectIndex];
 
//                 Ray localRay;
//                 localRay.pos = mul(sceneObject.worldToLocalMatrix, float4(ray.pos, 1)).xyz;
//                 localRay.dir = mul(sceneObject.worldToLocalMatrix, float4(ray.dir, 0)).xyz;
//                 localRay.invDir = 1 / localRay.dir;
        
//                 HitInfo localHitInfo = InitHitInfo();
        
//                 TraverseTrisBVH(localHitInfo, debugData, localRay, sceneObject.bvStartIndex);
                
//                 Material2 material = Materials[sceneObject.materialIndex];
//                 if (all(material.normalsTexLoc != -1)) localHitInfo.normal = SampleTexture(localHitInfo.uv, material.normalsTexLoc, material.normalsTexDims, TextureAtlas) * 2 - 1;

//                 if (localHitInfo.dst < hitInfo.dst)
//                 {
//                     hitInfo.dst = localHitInfo.dst;
//                     hitInfo.normal =  normalize(mul(sceneObject.localToWorldMatrix, float4(localHitInfo.normal, 0)).xyz);
//                     hitInfo.hitPoint = ray.pos + ray.dir * localHitInfo.dst;
//                     hitInfo.uv = localHitInfo.uv;
//                     hitInfo.materialIndex = sceneObject.materialIndex;
//                 }
//             }
//         }
//         else
//         {
//             // Check child BV intersections
//             BV bvA = BVs[bv.indexA];
//             float dstA = RayBVIntersect(ray, bvA); debugData.bvChecks++;
//             BV bvB = BVs[bv.indexB];
//             float dstB = RayBVIntersect(ray, bvB); debugData.bvChecks++;
 
//             // Push the nearest BV last, to avaluate it first
//             if (dstA < dstB)
//             {
//                 if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
//                 if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
//             }
//             else
//             {
//                 if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
//                 if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
//             }
//         }
//     }
// }
 
// HitInfo GetRayCollision (Ray ray, inout DebugData debugData)
// {
//     HitInfo hitInfo = InitHitInfo();
 
//     TraverseSceneBVH(hitInfo, debugData, ray);
 
//     return hitInfo;
// }
 
// int LightObjectReservoirSample(inout uint state)
// {
//     int firstIndex = randIntSpan(0, EmittingObjectsNum, state);
//     float firstWeight = LightObjects[firstIndex].areaApprox;
//     Reservoir reservoir = InitReservoir(firstIndex, firstWeight);
 
//     for (uint i = 0; i < SceneObjectReservoirTestsNum; i++)
//     {
//         int candidateIndex = randIntSpan(0, EmittingObjectsNum, state); // 1 -> EmittingObjectsNum
//         float candidateWeight = LightObjects[candidateIndex].areaApprox;
 
//         if (weightedRand(candidateWeight, reservoir.totWeights, state))
//         {
//             reservoir.chosenIndex = candidateIndex;
//             reservoir.chosenWeight = candidateWeight;
//         }
//         reservoir.totWeights += candidateWeight;
//     }
 
//     return reservoir.chosenIndex;
// }

// float GetTriArea(Triangle tri)
// {
//     float3 v0 = Vertices[tri.vertex0Index].pos;
//     float3 v1 = Vertices[tri.vertex1Index].pos;
//     float3 v2 = Vertices[tri.vertex2Index].pos;

//     float3 ab = v1 - v0;
//     float3 ac = v2 - v0;
//     float3 crossProduct = cross(ab, ac);
//     float area = length(crossProduct) * 0.5;
//     return area;
// }
 
// int TriReservoirSample(uint startTriIndex, uint endTriIndex, inout uint state)
// {
//     int firstIndex = randIntSpan(startTriIndex, endTriIndex, state);
//     float firstWeight = Triangles[firstIndex].area;
//     Reservoir reservoir = InitReservoir(firstIndex, firstWeight);
 
//     for (uint i = 0; i < TriReservoirTestsNum; i++)
//     {
//         int candidateIndex = randIntSpan(startTriIndex, endTriIndex, state);
//         float candidateWeight = Triangles[candidateIndex].area;
 
//         if (weightedRand(candidateWeight, reservoir.totWeights, state))
//         {
//             reservoir.chosenIndex = candidateIndex;
//             reservoir.chosenWeight = candidateWeight;
//         }
//         reservoir.totWeights += candidateWeight;
//     }
 
//     return reservoir.chosenIndex;
// }

// // Everything should work if this value is just proportional to the probability of the light ray bouncing at the given angle
// float GetBRDF(float hitAngleDot, float3 incomingDir, float3 outgoingDir, float3 hitNormal)
// {
//     return hitAngleDot;
// }
 
// float GenerateCandidateWeight(float sqrDst, float hitAngleDot, float3 incomingDir, float3 outgoingDir, float3 hitNormal, float brightness)
// {
//     return GetBRDF(hitAngleDot, incomingDir, outgoingDir, hitNormal) * brightness * hitAngleDot / sqrDst;
// }

// float3 GetRandWorldPointTri(Triangle tri, float4x4 localToWorldMatrix, inout uint state)
// {
//     float3 v0 = Vertices[tri.vertex0Index].pos;
//     float3 v1 = Vertices[tri.vertex1Index].pos;
//     float3 v2 = Vertices[tri.vertex2Index].pos;

//     float r1 = randNormalized(state);
//     float r2 = randNormalized(state);

//     // Ensure the point lies within the tri
//     if (r1 + r2 > 1.0)
//     {
//         r1 = 1.0 - r1;
//         r2 = 1.0 - r2;
//     }

//     float3 localPoint = v0 * (1.0 - r1 - r2) + v1 * r1 + v2 * r2;

//     float3 worldPoint = mul(localToWorldMatrix, float4(localPoint, 1.0)).xyz;

//     return worldPoint;
// }
 
// void GenerateCandidatesDL(HitInfo hitInfo, uint pixelIndex, inout uint state)
// {
//     // Weighted light object Sample
//     uint lightObjectIndex = LightObjectReservoirSample(state);
//     LightObject lightObject = LightObjects[lightObjectIndex];
//     uint startTriIndex = lightObject.triStart;
//     uint endTriIndex = lightObject.triStart + lightObject.totTris;

//     // Weighted tri Sample
//     uint triIndex = TriReservoirSample(startTriIndex, endTriIndex, state);
//     Triangle tri = Triangles[triIndex];
//     float3 worldPoint = GetRandWorldPointTri(tri, lightObject.localToWorldMatrix, state);

//     float3 dst = worldPoint - hitInfo.hitPoint;
//     float3 dir = normalize(dst);

//     // Validate direction
//     if (dot(hitInfo.normal, dir) < 0)
//     {
//         // If direction is invalid, abandon the current candidate by assigning an empty reservoir
//         Candidates[pixelIndex] = InitCandidateReservoir();
//         return;
//     }

//     float3 worldNormal = normalize(mul(lightObject.localToWorldMatrix, float4(tri.localNormal, 0)).xyz);

//     float hitAngleDot = max(dot(worldNormal, dir), 0);
//     float sqrDst = dot2(dst);

//     float candidateWeight = GenerateCandidateWeight(sqrDst, hitAngleDot, hitInfo.incomingDir, dir, hitInfo.normal, lightObject.brightness);

//     // Visibility reuse
//     // Expensive due to the need for casting a ray, but removes any and all visibility noise from the end result
//     #if VIS_REUSE
//         Ray shadowRay = InitRay(hitInfo.hitPoint, dir);
//         DebugData t;

//         // Traverse the scene to validate the candidate
//         // Then discard the candidate from further use if the target is occluded
//         HitInfo shadowHitInfo = GetRayCollision(shadowRay, t);
//         if (Materials[shadowHitInfo.materialIndex].brightness == 0) candidateWeight = 0;
//     #endif

//     CandidateReservoir candidateReservoir = InitCandidateReservoir(dir, hitInfo.hitPoint, hitInfo.normal, candidateWeight, candidateWeight, 1);
//     Candidates[pixelIndex] = candidateReservoir;
// }
 
// uint GetPixelIndex(uint2 threadID)
// {
//     return Resolution.x * threadID.y + threadID.x;
// }

// float3 GetFocalPos(float2 uv)
// {
//     float focalPosX = (uv.x - 0.5) * 2.0 * ViewSpaceDims.x;
//     float focalPosY = (uv.y - 0.5) * 2.0 * ViewSpaceDims.y;
//     float3 focalPos = float3(focalPosX, focalPosY, 1) * FocalPlaneFactor;
//     float3 worldFocalPos = mul(CameraTransform, focalPos) + WorldSpaceCameraPos;

//     return worldFocalPos;
// }

// float2 GetLastUV(float3 worldFocalPos)
// {
//     // Inverse of GetFocalPos(), and specialized for last frame camera data
//     float3 focalPos = worldFocalPos - LastWorldSpaceCameraPos;
//     float3 cameraFocalPos = mul(LastCameraTransformInverse, focalPos);
//     float3 ndcFocalPos = cameraFocalPos / FocalPlaneFactor;
//     float uvX = (ndcFocalPos.x / (2.0 * ViewSpaceDims.x)) + 0.5;
//     float uvY = (ndcFocalPos.y / (2.0 * ViewSpaceDims.y)) + 0.5;

//     return clamp(float2(uvX, uvY), 0.0, 1.0);
// }
 
// [numthreads(TN_RT,TN_RT,1)]
// void InitialTrace (uint3 id : SV_DispatchThreadID)
// {
//     if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
//     DebugData debugData = InitDebugData();
//     uint state = id.y * Resolution.x + id.x + FrameRand;
 
//     // Calculate focal plane world pos for the given pixel
//     float2 uv = float2(id.xy) / float2(Resolution);
//     float3 worldFocalPos = GetFocalPos(uv);
 
//     // Trace ray(s) through the scene
//     uint pixelIndex = GetPixelIndex(id.xy);
 
//     // Ray setup
//     Ray ray;
//     float3 jitter = mul(CameraTransform, float3(randPointInCircle(state) * DefocusStrength, 0));
//     ray.pos = WorldSpaceCameraPos + jitter * FocalPlaneFactor;
//     ray.dir = normalize(worldFocalPos - ray.pos);
//     ray.invDir = 1 / ray.dir;
 
//     // Cast first ray
//     HitInfo hitInfo = GetRayCollision(ray, debugData);
//     bool didHit = hitInfo.dst != 1.#INF;
//     hitInfo.incomingDir = ray.dir;

//     Material2 material = Materials[hitInfo.materialIndex];
//     float bump = material.bump == -1 ? SampleTexture(hitInfo.uv, material.bumpTexLoc, material.bumpTexDims, TextureAtlas).x : material.bump;
//     hitInfo.hitPoint -= hitInfo.incomingDir * bump;
 
//     // Generate a ray bounce direction candidate
//     if (didHit) GenerateCandidatesDL(hitInfo, pixelIndex, state);
 
//     // Save ray hit info data
//     HitInfos[pixelIndex] = hitInfo;
 
//     // Record data to textures
//     bool badMaxBVHDepth = MaxBVHDepth > MAX_BVH_DEPTH;
    
//     DebugOverlay[id.xy] = float4(debugData.triChecks / (float)DebugDataMaxValues.x, debugData.bvChecks / (float)DebugDataMaxValues.y, badMaxBVHDepth, 0);
    
//     DepthBuffer[id.xy] = hitInfo.dst;
//     NormalsBuffer[id.xy] = (hitInfo.normal + 1) * 0.5; // normalized to fit in a render texture
 
//     float3 firstHit = didHit ? hitInfo.hitPoint : float3(0, 0, 0);
//     if (FrameCount % 2 == 0) RayHitPointsA[id.xy] = firstHit;
//     else RayHitPointsB[id.xy] = firstHit;
// }
 
// // ---Kernel "SpatialReusePass": ---

// CandidateReservoir SpatialCandidateReservoirSample(uint pixelBaseIndex, int2 threadID, inout uint state)
// {
//     CandidateReservoir spatialReservoir = InitCandidateReservoir();
 
//     CandidateReservoir baseReservoir;
//     if (ReuseBufferCycle) baseReservoir = Candidates[pixelBaseIndex];
//     else baseReservoir = CandidatesB[pixelBaseIndex];

//     spatialReservoir = baseReservoir;

//     for (uint i = 0; i < TemporalCandidatesNum; i++)
//     {
//         int2 randOffset = float2(randIntSpan(-MaxOffset, MaxOffset, state), randIntSpan(-MaxOffset, MaxOffset, state));
//         int2 offsetID = threadID + randOffset;
//         if (offsetID.x >= Resolution.x || offsetID.y >= Resolution.y || any(offsetID) < 0 || DepthBuffer[offsetID] == 1.#INF) continue;

//         // Get candidate weight
//         uint pixelIndex = GetPixelIndex(offsetID);

//         CandidateReservoir candidateReservoir;
//         if (ReuseBufferCycle) candidateReservoir = Candidates[pixelIndex];
//         else candidateReservoir = CandidatesB[pixelIndex];
//         if (all(candidateReservoir.dir) == 0) continue;

//         float hitPointDiff = length(baseReservoir.hitPoint - candidateReservoir.hitPoint);
//         float normalDiffDeg = angleBetweenNormals(baseReservoir.normal, candidateReservoir.normal);
//         if (hitPointDiff > SpatialHitPointDiffThreshold || normalDiffDeg > SpatialNormalsAngleThreshold) continue;

//         if (weightedRand(candidateReservoir.chosenWeight, spatialReservoir.totWeights, state))
//         {
//             spatialReservoir.dir = candidateReservoir.dir;
//             spatialReservoir.chosenWeight = candidateReservoir.chosenWeight;
//             spatialReservoir.hitPoint = candidateReservoir.hitPoint;
//             spatialReservoir.normal = candidateReservoir.normal;
//         }

//         spatialReservoir.totWeights += candidateReservoir.totWeights;
//         spatialReservoir.totCandidates += candidateReservoir.totCandidates;
//     }
 
//     return spatialReservoir;
// }
 
// [numthreads(TN_RT,TN_RT,1)]
// void SpatialReusePass (uint3 id : SV_DispatchThreadID)
// {
//     if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y || DepthBuffer[id.xy] == 1.#INF) return;
//     uint state = id.y * Resolution.x + id.x + FrameRand;
 
//     uint pixelIndex = GetPixelIndex(id.xy);
 
//     // Spatial reservoir sampling for each ray
//     CandidateReservoir newCandidateReservoir = SpatialCandidateReservoirSample(pixelIndex, id.xy, state);

//     if (ReuseBufferCycle) CandidatesB[pixelIndex] = newCandidateReservoir;
//     else Candidates[pixelIndex] = newCandidateReservoir;
// }
 
// // ---Kernel "TransferToOriginal": ---
 
// [numthreads(TN_RT,TN_RT,1)]
// void TransferToOriginal (uint3 id : SV_DispatchThreadID)
// {
//     if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y || DepthBuffer[id.xy] == 1.#INF) return;
 
//     uint pixelIndex = GetPixelIndex(id.xy);
//     Candidates[pixelIndex] = CandidatesB[pixelIndex];
// }
 
// // --- Kernel "TemporalReuse": ---
 
// [numthreads(TN_RT,TN_RT,1)]
// void TemporalReuse (uint3 id : SV_DispatchThreadID)
// {
//     if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y || DepthBuffer[id.xy] == 1.#INF || FrameCount == 0) return;
//     uint state = id.y * Resolution.x + id.x + FrameRand;
 
//     // This frame pixel index
//     uint pixelIndex = GetPixelIndex(id.xy);

//     // Last Frame pixel index
//     float2 uv = float2(id.xy) / float2(Resolution);
//     float3 worldFocalPos = GetFocalPos(uv);
//     float2 lastFrameUV = GetLastUV(worldFocalPos);
//     int2 offsetID = int2(lastFrameUV * float2(Resolution));
//     if (length(uv - lastFrameUV) > TemporalPrecisionThreshold)
//     {
//         TemporalFrameBuffer[pixelIndex] = Candidates[pixelIndex];
//         return;
//     }
//     else offsetID = id.xy;

//     uint lastFramePixelIndex = GetPixelIndex(offsetID);
 
//     // --- Temporal reuse ---

//     // Evaluate pixel frame-to-frame movement
//     // Temp. Replace with a more sophisticated function.
//     float pixelHitPointMovement = length(RayHitPointsA[id.xy] - RayHitPointsB[id.xy]);

//     CandidateReservoir thisFrameReservoir = Candidates[pixelIndex];

//     if (pixelHitPointMovement <= PixelMovementThreshold)
//     {
//         CandidateReservoir lastFrameCandidate = TemporalFrameBuffer[lastFramePixelIndex];

//         float adjustedThisFrameWeight = thisFrameReservoir.totWeights * (1.0 - TemporalReuseWeight);
//         float adjustedLastFrameWeight = lastFrameCandidate.totWeights * TemporalReuseWeight;
//         float totWeights = adjustedThisFrameWeight + adjustedLastFrameWeight;
        
//         if (weightedRand(adjustedLastFrameWeight, totWeights, state))
//         {
//             thisFrameReservoir.dir = lastFrameCandidate.dir;
//             thisFrameReservoir.chosenWeight = lastFrameCandidate.chosenWeight;
//             thisFrameReservoir.hitPoint = lastFrameCandidate.hitPoint;
//         }
        
//         // Average the weights and candidates with respect to TemporalReuseWeight
//         thisFrameReservoir.totWeights = avg(thisFrameReservoir.totWeights * (1.0 - TemporalReuseWeight),
//                                             lastFrameCandidate.totWeights * TemporalReuseWeight);
//         thisFrameReservoir.totCandidates = avg(thisFrameReservoir.totCandidates * (1.0 - TemporalReuseWeight),
//                                                 lastFrameCandidate.totCandidates * TemporalReuseWeight);
//     }
    
//     Candidates[pixelIndex] = thisFrameReservoir;
//     TemporalFrameBuffer[pixelIndex] = thisFrameReservoir;
// }
 
// // --- Kernel "TraceRays": ---
 
// void UpdateCandidateWeight(float sqrDst, float hitAngleDot, float3 incomingDir, float3 outgoingDir, float3 hitNormal, float brightness, uint pixelIndex)
// {
//     // Calculate new weight
//     bool validCandidate = brightness > 0;
//     if (!validCandidate) return;
//     float newWeight = GenerateCandidateWeight(sqrDst, hitAngleDot, incomingDir, outgoingDir, hitNormal, brightness);

//     // Apply new weight
//     TemporalFrameBuffer[pixelIndex].chosenWeight = newWeight;

//     return;
// }

// Material2 GetMaterial(HitInfo hitInfo)
// {
//     Material2 material = InitMaterial();
//     if (hitInfo.dst != 1.#INF) material = Materials[hitInfo.materialIndex];
//     return material;
// }

// bool IsInvalidCandidate(uint bounceCount, Material2 material, HitInfo hitInfo, Ray ray)
// {
//     return (bounceCount == 1 && material.brightness <= 0) || 
//            (bounceCount == 0 && dot(hitInfo.normal, ray.dir) < 0) || 
//            (hitInfo.dst == 1.#INF);
// }

// float3 GetScatterDirection(HitInfo hitInfo, inout uint state)
// {
//     return normalize(hitInfo.normal + randPointOnUnitSphere(state));
// }

// float3 GetRayDirection(Ray ray, HitInfo hitInfo, Material2 material, bool isSpecularBounce, inout uint state)
// {
//     float3 scatterDir = GetScatterDirection(hitInfo, state);
//     float3 specularDir = reflect(ray.dir, hitInfo.normal);
//     return normalize(lerp(scatterDir, specularDir, (1 - material.roughness) * isSpecularBounce));
// }

// float3 GetEmittedLight(Material2 material, HitInfo hitInfo)
// {
//     float3 sampleCol = all(material.col == -1) ? 
//                         SampleTexture(hitInfo.uv, material.colTexLoc, material.colTexDims, TextureAtlas) : 
//                         material.col;
//     return sampleCol * material.brightness / sqr(hitInfo.dst);
// }

// float3 GetRayColFactor(Ray ray, HitInfo hitInfo, Material2 material, bool isSpecularBounce)
// {
//     float3 specCol = 1;
//     float3 sampleCol = all(material.col == -1) ? 
//                         SampleTexture(hitInfo.uv, material.colTexLoc, material.colTexDims, TextureAtlas) : 
//                         material.col;
//     return lerp(sampleCol, specCol, isSpecularBounce);
// }

// TraceInfo Trace(Ray ray, HitInfo hitInfo, uint pixelIndex, inout DebugData debugData, inout uint state)
// {
//     TraceInfo traceInfo;
//     traceInfo.totTravelDst = 0;
//     traceInfo.rayColor = dot(hitInfo.normal, ray.dir);
//     traceInfo.directLight = float3(0, 0, 0);
//     traceInfo.indirectLight = float3(0, 0, 0);

//     for (uint bounceCount = 0; bounceCount <= MaxBounceCount; bounceCount++) {
//         if (hitInfo.dst == 1.#INF) break;

//         Material2 material = GetMaterial(hitInfo);

//         // Validate candidate and reset if invalid
//         if (IsInvalidCandidate(bounceCount, material, hitInfo, ray)) Candidates[pixelIndex] = InitCandidateReservoir();

//         // Calculate new ray direction for bounces beyond the first
//         if (bounceCount != 0)
//         {
//             float3 incomingDir = ray.dir;
//             bool isSpecularBounce = ScatterProbability < randNormalized(state);
//             ray.dir = GetRayDirection(ray, hitInfo, material, isSpecularBounce, state);

//             // Validate ray direction
//             float hitAngleDot = dot(hitInfo.normal, ray.dir);
//             if (hitAngleDot < 0) ray.dir = -ray.dir;

//             // Weight recalculations
//             // Update candidate weight on first bounce
//             #if WEIGHT_RECALC
//                 if (bounceCount == 1) UpdateCandidateWeight(sqr(hitInfo.dst), hitAngleDot, incomingDir, ray.dir, hitInfo.normal, material.brightness, pixelIndex);
//             #endif
//         }

//         // Update trace information
//         float3 emittedLight = GetEmittedLight(material, hitInfo);
//         traceInfo.rayColor *= GetRayColFactor(ray, hitInfo, material, bounceCount != 0);
//         traceInfo.totTravelDst += hitInfo.dst;

//         if (bounceCount == 0) traceInfo.directLight += emittedLight * traceInfo.rayColor;
//         else traceInfo.indirectLight += emittedLight * traceInfo.rayColor;

//         // Recast ray for the next bounce
//         if (bounceCount != MaxBounceCount) hitInfo = GetRayCollision(ray, debugData);
//     }

//     return traceInfo;
// }

// [numthreads(TN_RT,TN_RT,1)]
// void TraceRays (uint3 id : SV_DispatchThreadID)
// {
//     if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
//     DebugData debugData = InitDebugData(); // Debug data never gets recorded for this kernel
//     uint state = id.y * Resolution.x + id.x + FrameRand;
 
//     uint pixelIndex = GetPixelIndex(id.xy);

//     // Retrieve stored hitInfo data
//     HitInfo hitInfo = HitInfos[id.y * Resolution.x + id.x];
 
//     // --- Trace the ray through the scene ---

//     // Get a ray direction from the current candidates
//     CandidateReservoir candidateReservoir = Candidates[pixelIndex];

//     // Return no color if initial ray trace missed
//     if (hitInfo.dst == 1.#INF)
//     {
//         float3 col = SampleEnvironmentMap(hitInfo.incomingDir);
//         Result[id.xy] = float4(col.x, col.y, col.z, 0);
//         return;
//     }
//     // Return the emitted light of the first hit object if no further ray direction candidates are found
//     else if (all(candidateReservoir.dir) == 0 || dot(hitInfo.normal, candidateReservoir.dir) < 0)
//     {
//         Material2 material = Materials[hitInfo.materialIndex];

//         // Calculate new traceInfo values
//         float3 sampleCol = all(material.col == -1) ? SampleTexture(hitInfo.uv, material.colTexLoc, material.colTexDims, TextureAtlas) : material.col;
//         float3 emittedLight = sampleCol * material.brightness / sqr(hitInfo.dst);
//         float3 col = emittedLight;

//         Result[id.xy] = float4(col, 0);
//         return;
//     }

//     // Ray setup
//     Ray ray;
//     ray.pos = hitInfo.hitPoint;
//     ray.dir = candidateReservoir.dir;
//     ray.invDir = 1 / ray.dir;

//     // Trace ray
//     TraceInfo traceInfo = Trace(ray, hitInfo, pixelIndex, debugData, state);

//     // Record traceInfo
//     float avgCandidateWeight = candidateReservoir.totWeights / candidateReservoir.totCandidates;
//     float correctionWeight = avgCandidateWeight / candidateReservoir.chosenWeight;
//     traceInfo.indirectLight *= correctionWeight;
    
//     float3 combinedLight = traceInfo.directLight + (traceInfo.indirectLight / sqr(traceInfo.totTravelDst)); // Compensation for candidate weight?

//     // Record ray tracer result
//     Result[id.xy] = float4(combinedLight, 0);
// }
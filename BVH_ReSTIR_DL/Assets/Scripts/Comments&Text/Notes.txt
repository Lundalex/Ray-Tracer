ReStir paper: https://cdn.pharr.org/ReSTIR.pdf
ReStir = Reservoir-based SpatioTemporal Importance Resampling

V-CERS-C-1061267062-DKOVG2-D3-DH

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
1. Temporal reuse
2. Visibility reuse - perform visibility check for each candidate BEFORE spatio-temporal reuse in order to decrease the amount of visibiliy noise (noice caused by false candidates)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!! LightObjects should be kept at a low triangle count for better performance

shift + option + 8 = {}
option + 8 = []
fn + Z = undo
shift + fn + Z = undo an undo
shift + fn + 7 = comment out / undo comment out
option + 7 = |
170-180 after 5s

// ReSTIR new:


#pragma kernel InitialTrace // 0
#pragma kernel TraceRays // 1
#pragma kernel SpatialReusePass // 2
#pragma kernel TransferToOriginal // 3

#include "RendererResources.hlsl"

// Constants
const uint TrisNum;
const uint BVsNum;
const uint MaxBVHDepth;
const uint SceneBVHStartIndex;
const uint SceneObjectsNum;
const float ScatterProbability;

// Render quality settings
const uint MaxBounceCount;
const uint RaysPerPixel; // Currectly always set to 1

// View settings
const int2 Resolution;
const float2 ViewSpaceDims;
const float DefocusStrength;
const float FocalPlaneFactor;

// Camera orientation and transform
const float3 WorldSpaceCameraPos;
const float3x3 CameraTransform;

// Per frame
const uint FrameRand; // "random" value from 0 to 999999, gets reset each frame
const uint FrameCount; // Each frame: FrameCount++
const uint UseExistingCandidates; // 1 == true, 0 == false

// Debug
const int2 DebugDataMaxValues;

// Temp tex.
const uint2 TexDims;

// ReSTIR - Reservoir sample quality
const uint SceneObjectReservoirTestsNum;
const uint TriReservoirTestsNum;

// ReStir - Spatial reuse
const int ReuseBufferCycle; // 1 == true, 0 == false
const int Offset;

// ReSTIR - Other
const uint EmittingObjectsNum;
const float TotArea;

RWStructuredBuffer<HitInfo> HitInfos;
RWStructuredBuffer<CandidateReservoir> Candidates; // float4(dir, weight)
RWStructuredBuffer<float4> CandidatesB; // buffer double to "Candidates". Used for spatio-temporal reuse

StructuredBuffer<Tri> Tris;
StructuredBuffer<BoundingVolume> BVs;
StructuredBuffer<SceneObject> SceneObjects;
StructuredBuffer<LightObject> LightObjects;
StructuredBuffer<Material2> Materials;

Texture2D<float4> TestTexture;

// Output textures
RWTexture2D<float4> Result;
RWTexture2D<float4> DebugOverlay;
RWTexture2D<float4> RayHitPoints;

float3 ApplyCameraTransform(float3 point2)
{
    return mul(CameraTransform, point2);
}

float TriDstSqr(float3 p, float3 a, float3 b, float3 c )
{
  float3 ba = b - a; float3 pa = p - a;
  float3 cb = c - b; float3 pb = p - b;
  float3 ac = a - c; float3 pc = p - c;
  float3 nor = cross( ba, ac );

  return (sign(dot(cross(ba,nor),pa)) +
         sign(dot(cross(cb,nor),pb)) +
         sign(dot(cross(ac,nor),pc))<2.0)
         ?
         min( min(
         dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),
         dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),
         dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )
         :
         dot(nor,pa)*dot(nor,pa)/dot2(nor);
}

TriHitInfo RayTriangleIntersect(Ray ray, Tri tri)
{
    float3 edgeAB = tri.vB - tri.vA;
    float3 edgeAC = tri.vC - tri.vA;
    float3 normalVector = cross(edgeAB, edgeAC);
    float3 ao = ray.pos - tri.vA;
    float3 dao = cross(ao, ray.dir);

    float determinant = -dot(ray.dir, normalVector);
    float invDet = 1 / determinant;

    // Calculate dst to triangle & barycentric coordinates of intersection point
    float dst = dot(ao, normalVector) * invDet;
    float u = dot(edgeAC, dao) * invDet;
    float v = -dot(edgeAB, dao) * invDet;
    float w = 1 - u - v;

    // Initialize tri hit info
    TriHitInfo triHitInfo;
    triHitInfo.didHit = determinant >= 1E-8 && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
    triHitInfo.uv = triHitInfo.didHit ? tri.uvA * w + tri.uvB * u + tri.uvC * v : float2(0, 0);
    triHitInfo.dst = dst;
    return triHitInfo;
}

float RayBVIntersect(Ray ray, BoundingVolume bv)
{
    float3 tMin = (bv.min - ray.pos) / ray.dir;
    float3 tMax = (bv.max - ray.pos) / ray.dir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    bool didHit = tFar >= tNear && tFar > 0;
    float dst = didHit ? tNear > 0 ? tNear : 0 : 1.#INF;

    return dst;
};

void TraverseTrisBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray, uint bvStartIndex)
{
    uint bvStack[MAX_BVH_DEPTH + 1];
    uint stackPointer = 0;
    bvStack[stackPointer++] = bvStartIndex;

    while (stackPointer > 0)
    {
        BoundingVolume bv = BVs[bvStack[--stackPointer]];

        bool isLeaf = bv.indexA >= 0;
        bv.indexA = abs(bv.indexA);
        bv.indexB = abs(bv.indexB);
        
        if (isLeaf)
        {
            for (int triIndex = bv.indexA; triIndex < bv.indexA + bv.indexB; triIndex++)
            {
                Tri tri = Tris[triIndex];
                TriHitInfo triHitInfo = RayTriangleIntersect(ray, tri); debugData.triChecks++;
                
                if (triHitInfo.didHit && triHitInfo.dst < hitInfo.dst)
                {
                    hitInfo.dst = triHitInfo.dst;
                    hitInfo.uv = triHitInfo.uv;
                    hitInfo.normal = tri.worldNormal;
                }
            }
        }
        else
        {
            // Check child BV intersections
            BoundingVolume bvA = BVs[bv.indexA];
            float dstA = RayBVIntersect(ray, bvA); debugData.bvChecks++;
            BoundingVolume bvB = BVs[bv.indexB];
            float dstB = RayBVIntersect(ray, bvB); debugData.bvChecks++;

            // Push the nearest BV last, to avaluate it first
            if (dstA < dstB)
            {
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
            }
            else
            {
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
            }
        }
    }
}

void TraverseSceneBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray)
{
    uint bvStack[MAX_BVH_DEPTH + 1];
    uint stackPointer = 0;
    bvStack[stackPointer++] = SceneBVHStartIndex;

    while (stackPointer > 0)
    {
        BoundingVolume bv = BVs[bvStack[--stackPointer]];

        bool isLeaf = bv.indexA >= 0;
        bv.indexA = abs(bv.indexA);
        bv.indexB = abs(bv.indexB);
        
        if (isLeaf)
        {
            for (int sceneObjectIndex = bv.indexA; sceneObjectIndex < bv.indexA + bv.indexB; sceneObjectIndex++)
            {
                SceneObject sceneObject = SceneObjects[sceneObjectIndex];

                Ray localRay;
                localRay.pos = mul(sceneObject.worldToLocalMatrix, float4(ray.pos, 1)).xyz;
                localRay.dir = mul(sceneObject.worldToLocalMatrix, float4(ray.dir, 0)).xyz;
                // localRay.invDir = 1 / localRay.dir; (optimisation to add)
        
                HitInfo localHitInfo = InitHitInfo();
        
                TraverseTrisBVH(localHitInfo, debugData, localRay, sceneObject.bvStartIndex);
        
                if (localHitInfo.dst < hitInfo.dst)
                {
                    hitInfo.dst = localHitInfo.dst;
                    hitInfo.normal = localHitInfo.normal;
                    hitInfo.hitPoint = ray.pos + ray.dir * hitInfo.dst;
                    hitInfo.uv = localHitInfo.uv;
                    hitInfo.materialIndex = sceneObject.materialIndex;
                }
            }
        }
        else
        {
            // Check child BV intersections
            BoundingVolume bvA = BVs[bv.indexA];
            float dstA = RayBVIntersect(ray, bvA); debugData.bvChecks++;
            BoundingVolume bvB = BVs[bv.indexB];
            float dstB = RayBVIntersect(ray, bvB); debugData.bvChecks++;

            // Push the nearest BV last, to avaluate it first
            if (dstA < dstB)
            {
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
            }
            else
            {
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
            }
        }
    }
}

HitInfo GetRayCollision (Ray ray, inout DebugData debugData)
{
    HitInfo hitInfo = InitHitInfo();

    TraverseSceneBVH(hitInfo, debugData, ray);

    return hitInfo;
}

float3 SampleTexColor(float2 uv)
{
    float2 texCoords = int2(uv * TexDims);

    int2 iTexCoords = int2(texCoords);
    float2 fTexCoords = frac(texCoords);

    int2 texel00 = iTexCoords % TexDims;
    int2 texel10 = (iTexCoords + int2(1, 0)) % TexDims;
    int2 texel01 = (iTexCoords + int2(0, 1)) % TexDims;
    int2 texel11 = (iTexCoords + int2(1, 1)) % TexDims;

    float4 col00 = TestTexture[texel00];
    float4 col10 = TestTexture[texel10];
    float4 col01 = TestTexture[texel01];
    float4 col11 = TestTexture[texel11];

    float4 col0 = lerp(col00, col10, fTexCoords.x);
    float4 col1 = lerp(col01, col11, fTexCoords.x);
    float4 col = lerp(col0, col1, fTexCoords.y);

    return col.xyz;
}

int LightObjectReservoirSample(inout uint state)
{
    int firstIndex = randIntSpan(0, EmittingObjectsNum, state); // 1 -> EmittingObjectsNum
    float firstWeight = LightObjects[firstIndex].areaApprox;
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);

    for (uint i = 0; i < SceneObjectReservoirTestsNum; i++)
    {
        int candidateIndex = randIntSpan(0, EmittingObjectsNum, state); // 1 -> EmittingObjectsNum
        float candidateWeight = LightObjects[candidateIndex].areaApprox;

        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }

    return reservoir.chosenIndex;
}

int TriReservoirSample(uint startTriIndex, uint endTriIndex, inout uint state)
{
    int firstIndex = randIntSpan(startTriIndex, endTriIndex, state);
    float firstWeight = GetTriArea(Tris[firstIndex]);
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);

    for (uint i = 0; i < TriReservoirTestsNum; i++)
    {
        int candidateIndex = randIntSpan(startTriIndex, endTriIndex, state);
        float candidateWeight = GetTriArea(Tris[candidateIndex]);

        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }

    return reservoir.chosenIndex;
}

// For now, BSDFs won't be considered
float GetBRDF() { return 1; }

float GenerateCandidateWeight(float sqrDst, float hitAngleDot, float brightness)
{
    return GetBRDF() * brightness * hitAngleDot / sqrDst;
}

void GenerateCandidatesDL2(float3 hitNormal, float3 pos, uint pixelIndex, inout uint state)
{
    for (uint i = 0; i < RaysPerPixel; i++)
    {
        // Weighted light object Sample
        uint lightObjectIndex = LightObjectReservoirSample(state);
        LightObject lightObject = LightObjects[lightObjectIndex];
        uint startTriIndex = lightObject.triStart;
        uint endTriIndex = lightObject.triStart + lightObject.totTris;

        // Weighted tri Sample
        uint triIndex = TriReservoirSample(startTriIndex, endTriIndex, state);
        Tri tri = Tris[triIndex];
        float3 worldPoint = GetRandWorldPointTri(tri, lightObject.localToWorldMatrix, state);

        float3 dst = worldPoint - pos;
        float3 dir = normalize(dst);

        uint candidateIndex = pixelIndex * RaysPerPixel + i;
        
        // Validate direction
        if (dot(hitNormal, dir) < 0)
        {
            // If direction is invalid, abandon the current candidate
            Candidates[candidateIndex] = float4(0, 0, 0, 0);
            continue;
        }

        float hitAngleDot = max(dot(tri.worldNormal, dir), 0);
        
        Candidates[candidateIndex] = float4(dir, GenerateCandidateWeight(dot2(dst), hitAngleDot, lightObject.brightness));
    }
}

uint GetPixelIndex(uint2 threadID)
{
    uint rayBaseIndex = (Resolution.x * threadID.y + threadID.x) * RaysPerPixel;
    return rayBaseIndex;
}

[numthreads(TN_RT,TN_RT,1)]
void InitialTrace (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    DebugData debugData = InitDebugData();
    uint state = id.y * Resolution.x + id.x + FrameRand;

    // Calculate focal plane world pos for the given pixel
    float focalPosX = (float(id.x) / Resolution.x - 0.5) * 2.0 * ViewSpaceDims.x;
    float focalPosY = (float(id.y) / Resolution.y - 0.5) * 2.0 * ViewSpaceDims.y;
    float3 focalPos = float3(focalPosX, focalPosY, 1) * FocalPlaneFactor;
    float3 worldFocalPos = ApplyCameraTransform(focalPos) + WorldSpaceCameraPos;

    // Trace ray(s) through the scene
    uint pixelIndex = GetPixelIndex(id.xy);
    TraceInfo combinedTraceInfo;

    // Ray setup
    Ray ray;
    ray.pos = WorldSpaceCameraPos;
    ray.dir = normalize(worldFocalPos - ray.pos);

    // Cast first ray
    HitInfo hitInfo = GetRayCollision(ray, debugData);
    bool didHit = hitInfo.dst != 1.#INF;

    // Use ReStir to generate ray bounce direction candidates
    if (didHit && !UseExistingCandidates) GenerateCandidatesDL2(hitInfo.normal, hitInfo.hitPoint, pixelIndex, state);

    // Save ray hit info data
    HitInfos[pixelIndex] = hitInfo;

    // Store hit point data for debug purposes
    float3 firstHit = didHit ? hitInfo.hitPoint : float3(0, 0, 0);
    RayHitPoints[id.xy] = float4(firstHit, 0);

    // Record debug data
    bool badMaxBVHDepth = MaxBVHDepth >= MAX_BVH_DEPTH;
    DebugOverlay[id.xy] = float4(debugData.triChecks / (float)DebugDataMaxValues.x, debugData.bvChecks / (float)DebugDataMaxValues.y, badMaxBVHDepth, 0);
}

// --- Kernel "TraceRays": ---

void UpdateCandidateWeight(float brightness, uint candidateIndex)
{
    bool validCandidate = brightness > 0;
    float correctionWeight = validCandidate ? 1.#INF: 1.#INF;

    // Candidate weight should also be modified according to the hit light (light * hitAngleDot * ...) ! ! !

    // The candiate is invalid if the ray hit an unlit object after the first bounce

    return;
}

TraceInfo Trace(Ray ray, HitInfo hitInfo, uint candidateIndex, inout DebugData debugData, inout uint state)
{
    TraceInfo traceInfo;
    traceInfo.rayColor = float3(1, 1, 1);
    traceInfo.incomingLight = float3(0, 0, 0);

    for (uint bounceCount = 0; bounceCount <= MaxBounceCount; bounceCount++) // MaxBounceCount = 1 for direct lighting 
    {
        if (hitInfo.dst == 1.#INF) break;

        bool didHit = hitInfo.dst != 1.#INF;
        
        // Material2 material = didHit ? Materials[hitInfo.materialIndex] : InitMaterial();
        Material2 material = InitMaterial();
        if (didHit) { material = Materials[hitInfo.materialIndex]; }

        // Candidate validation
        // UpdateCandidateWeight(float brightness, uint candidateIndex) ! ! !
        bool invalidCandidate = (bounceCount == 1 && (material.brightness <= 0) < 0) || (bounceCount == 0 && dot(hitInfo.normal, ray.dir) < 0);
        if (invalidCandidate)
        {
            Candidates[candidateIndex] = float4(0, 0, 0, 0);
        }

        // Calculate new ray pos
        ray.pos = hitInfo.hitPoint - hitInfo.normal * 0.001; // epsilon offset

        // Ray direction already decided for first bounce!
        bool isSpecularBounce = false;
        if (bounceCount != 0)
        {
            // Calculate new ray direction
            // isSpecularBounce == False -> ray.dir = scatterDir
            // isSpecularBounce == True -> ray.dir = norm(lerp(scatterDir, specularDir, material.smoothness))
            isSpecularBounce = ScatterProbability < randNormalized(state);
            // Cosine weighted randPointOnUnitSphere. This removes the need for any "light spread" calculations
            float3 scatterDir = normalize(hitInfo.normal + randPointOnUnitSphere(state));
            float3 specularDir = reflect(ray.dir, hitInfo.normal);
            ray.dir = normalize(lerp(scatterDir, specularDir, material.smoothness * isSpecularBounce));

            // Validate ray direction
            if (dot(hitInfo.normal, ray.dir) < 0)
            {
                ray.dir = -ray.dir;
            }
        }

        // Calculate new traceInfo values
        float3 sampleCol = material.color; // /SampleTexColor(hitInfo.uv)
        float3 emittedLight = sampleCol * material.brightness / sqr(hitInfo.dst);
        traceInfo.incomingLight += emittedLight * traceInfo.rayColor;
        traceInfo.rayColor *= lerp(material.color, material.specularColor, isSpecularBounce);

        // Evaluate the amount of light contributed by the candidate and update it's weight accordingly (linear relationship)
        if (bounceCount == 1) UpdateCandidateWeight(material.brightness, candidateIndex); 

        // Recast ray
        if (bounceCount != MaxBounceCount) hitInfo = GetRayCollision(ray, debugData);
    }

    return traceInfo;
}

[numthreads(TN_RT,TN_RT,1)]
void TraceRays (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    DebugData debugData = InitDebugData(); // Debug data never gets recorded for this kernel
    uint state = id.y * Resolution.x + id.x + FrameRand;

    uint pixelIndex = GetPixelIndex(id.xy); // removed "+ i" to prevent issues if RaysPerPixel != 1

    TraceInfo combinedTraceInfo;

    // Retrieve stored hitInfo data
    HitInfo hitInfo = HitInfos[id.y * Resolution.x + id.x];

    // Trace each ray through the scene
    for (uint rayIndex = 0; rayIndex < RaysPerPixel; rayIndex++)
    {
        // Get a ray direction from the current candidates
        uint candidateIndex = pixelIndex * RaysPerPixel + rayIndex;
        float4 RISData = Candidates[candidateIndex];

        // Return no color if initial ray trace missed
        if (hitInfo.dst == 1.#INF)
        {
            Result[id.xy] = float4(0, 0, 0, 0);
            return;
        }
        // Return the emitted light of the first hit object if no further ray direction candidates are found
        else if (all(RISData.xyz) == 0)
        {
            Material2 material = Materials[hitInfo.materialIndex];
    
            // Calculate new traceInfo values
            float3 sampleCol = material.color; // /SampleTexColor(hitInfo.uv)
            float3 emittedLight = sampleCol * material.brightness / sqr(hitInfo.dst);
            float3 col = emittedLight;
    
            Result[id.xy] = float4(col, 0);
            return;
        }

        // Ray setup
        Ray ray;
        ray.pos = hitInfo.hitPoint;
        ray.dir = RISData.xyz;

        // Trace ray
        TraceInfo traceInfo = Trace(ray, hitInfo, candidateIndex, debugData, state);

        // Record traceInfo
        float correctionWeight = RISData.w;
        combinedTraceInfo.incomingLight += traceInfo.incomingLight * correctionWeight;
    }
    combinedTraceInfo.incomingLight /= RaysPerPixel;

    float3 col = combinedTraceInfo.incomingLight;

    // Record ray tracer result
    Result[id.xy] = float4(col, 0);
}

// ---Kernel "SpatialReusePass": ---

int SpatialCandidateReservoirSample(uint pixelBaseIndex, uint rayIndex, inout uint state)
{
    Reservoir reservoir = InitReservoir(-1, 0);

    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            uint pixelIndex = pixelBaseIndex + Offset * (y * Resolution.x + x);
            uint candidateIndex = pixelIndex * RaysPerPixel + rayIndex;
            float candidateWeight = ReuseBufferCycle ? Candidates[candidateIndex].w : CandidatesB[candidateIndex].w;

            if (weightedRand(candidateWeight, reservoir.totWeights, state))
            {
                reservoir.chosenIndex = candidateIndex;
                reservoir.chosenWeight = candidateWeight;
            }

            reservoir.totWeights += candidateWeight;
        }
    }

    return reservoir.chosenIndex;
}

[numthreads(TN_RT,TN_RT,1)]
void SpatialReusePass (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    uint state = id.y * Resolution.x + id.x + FrameRand;

    // Trace ray(s) through the scene
    uint pixelBaseIndex = GetPixelIndex(id.xy); // removed "+ i" to prevent issues if RaysPerPixel != 1
    uint candidateBaseIndex = pixelBaseIndex * RaysPerPixel;

    // Spatial reservoir sampling for each ray
    // Each ray only samples from other rays with the same pixel ray index. There should also be a ray-Reuse pass, similar to the temporal reuse!
    for (uint rayIndex = 0; rayIndex < RaysPerPixel; rayIndex++)
    {
        int newCandidateIndex = SpatialCandidateReservoirSample(pixelBaseIndex, rayIndex, state);
        if (ReuseBufferCycle) { CandidatesB[candidateBaseIndex] = Candidates[newCandidateIndex]; }
        else { Candidates[candidateBaseIndex] = CandidatesB[newCandidateIndex]; }
    }
}

// ---Kernel "TransferToOriginal": ---

[numthreads(TN_RT,TN_RT,1)]
void TransferToOriginal (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;

    uint pixelBaseIndex = GetPixelIndex(id.xy); // removed "+ i" to prevent issues if RaysPerPixel != 1
    uint candidateBaseIndex = pixelBaseIndex * RaysPerPixel;

    for (uint rayIndex = 0; rayIndex < RaysPerPixel; rayIndex++)
    {
        uint candidateIndex = candidateBaseIndex + rayIndex;
        Candidates[candidateIndex] = CandidatesB[candidateIndex];
    }
}







Reservoir CandidateReservoirSample(uint startIndex, uint endIndex, inout uint state)
{
    uint firstIndex = randIntSpan(startIndex, endIndex, state);
    float firstWeight = Candidates[firstIndex].w;
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);

    for (uint i = 0; i < CandidateReservoirTestsNum; i++)
    {
        uint candidateIndex = randIntSpan(startIndex, endIndex, state);
        float4 candidate = Candidates[candidateIndex];
        if (candidate.w == 0) continue;
        float candidateWeight = candidate.w;

        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }

    return reservoir;
}

// OLD:::::


float3[] candidatesNum = new float3[Resolution.x * Resolution.y * RaysPerPixel * SceneObjectCandidatesNum * TriCandidatesNum];

--- MainHelper ---

using Unity.Mathematics;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;

// Import utils from Resources.cs
using Resources;
// Usage: Utils.(functionName)()

public class MeshHelper : MonoBehaviour
{
    public GameObject[] sceneObjects;
    public int MaxDepthBVH;
    public int SplitResolution; // ex. 10 -> Each BV split will test 10 increments for each component x,y,z (30 tests total)
    public int TriMaxPerOBJ;
    private SceneObjectData[] sceneObjectsData;
    private BoundingVolume[] loadedBoundingVolumes = new BoundingVolume[0];
    private Tri[] loadedTris = new Tri[0];
    private List<(Mesh mesh, int triStartIndex, int bvStartIndex)> LoadedMeshes = new();
    public Tri2[] LoadOBJ(Mesh mesh)
    {
        Vector3[] vertices = mesh.vertices;
        int[] triangles = mesh.triangles;
        int triNum = triangles.Length / 3;

        // Set tris data
        Tri2[] tris = new Tri2[TriMaxPerOBJ == -1 ? triNum : Mathf.Min(triNum, TriMaxPerOBJ)];
        for (int triCount = 0; triCount < (TriMaxPerOBJ == -1 ? triNum : Mathf.Min(triNum, TriMaxPerOBJ)); triCount++)
        {
            int triCount3 = 3 * triCount;
            int indexA = triangles[triCount3];
            int indexB = triangles[triCount3 + 1];
            int indexC = triangles[triCount3 + 2];

            tris[triCount] = new Tri2
            {
                vA = vertices[indexA],
                vB = vertices[indexB],
                vC = vertices[indexC],
            };
            tris[triCount].min = GetTri2Min(tris[triCount]);
            tris[triCount].max = GetTri2Max(tris[triCount]);
            tris[triCount].mid = Func.Avg(tris[triCount].min, tris[triCount].max);
        }

        return tris;
    }

    private float3 GetTri2Min(Tri2 tri)
    {
        float3 min = new float3(float.MaxValue, float.MaxValue, float.MaxValue);

        min.x = Mathf.Min(min.x, tri.vA.x, tri.vB.x, tri.vC.x);
        min.y = Mathf.Min(min.y, tri.vA.y, tri.vB.y, tri.vC.y);
        min.z = Mathf.Min(min.z, tri.vA.z, tri.vB.z, tri.vC.z);

        return min;
    }
    private float3 GetTri2Min(Tri2[] tris)
    {
        float3 min = new float3(float.MaxValue, float.MaxValue, float.MaxValue);

        foreach (var tri in tris)
        {
            min.x = Mathf.Min(min.x, tri.min.x);
            min.y = Mathf.Min(min.y, tri.min.y);
            min.z = Mathf.Min(min.z, tri.min.z);
        }

        return min;
    }
    private float3 GetTri2Min(List<Tri2> tris)
    {
        float3 min = new float3(float.MaxValue, float.MaxValue, float.MaxValue);

        foreach (var tri in tris)
        {
            min.x = Mathf.Min(min.x, tri.min.x);
            min.y = Mathf.Min(min.y, tri.min.y);
            min.z = Mathf.Min(min.z, tri.min.z);
        }

        return min;
    }

    private float3 GetTri2Max(Tri2 tri)
    {
        float3 max = new float3(float.MinValue, float.MinValue, float.MinValue);

        max.x = Mathf.Max(max.x, tri.vA.x, tri.vB.x, tri.vC.x);
        max.y = Mathf.Max(max.y, tri.vA.y, tri.vB.y, tri.vC.y);
        max.z = Mathf.Max(max.z, tri.vA.z, tri.vB.z, tri.vC.z);

        return max;
    }
    private float3 GetTri2Max(Tri2[] tris)
    {
        float3 max = new float3(float.MinValue, float.MinValue, float.MinValue);

        foreach (var tri in tris)
        {
            max.x = Mathf.Max(max.x, tri.max.x);
            max.y = Mathf.Max(max.y, tri.max.y);
            max.z = Mathf.Max(max.z, tri.max.z);
        }

        return max;
    }
    private float3 GetTri2Max(List<Tri2> tris)
    {
        float3 max = new float3(float.MinValue, float.MinValue, float.MinValue);

        foreach (var tri in tris)
        {
            max.x = Mathf.Max(max.x, tri.max.x);
            max.y = Mathf.Max(max.y, tri.max.y);
            max.z = Mathf.Max(max.z, tri.max.z);
        }

        return max;
    }

    private float GetBoxArea(float3 vA, float3 vB)
    {
        float length = Mathf.Abs(vA.x - vB.x);
        float width = Mathf.Abs(vA.y - vB.y);
        float height = Mathf.Abs(vA.z - vB.z);

        float area = 2 * (length * width + width * height + height * length);
        
        return area;
    }

    float GetCost<T>(List<T> componentsChildA, List<T> componentsChildB)
    {
        float costA = GetBoxArea(GetTri2Min(componentsChildA), GetTri2Max(componentsChildA)) * componentsChildA.Count;
        float costB = GetBoxArea(GetTri2Min(componentsChildB), GetTri2Max(componentsChildB)) * componentsChildB.Count;
        float totCost = costA + costB;

        return totCost;
    }

    private void SwapPair<T>(ref T[] array, int indexA, int indexB) => (array[indexB], array[indexA]) = (array[indexA], array[indexB]);

    private float3 GetMidPos(Tri2 tri)
    {
        return new float3(0,0,0);
    }

    private int DivideIntoSubGroupsRef<T>(ref T[] components, int axis, float3 splitCoord, int triStart, int totTris)
    {
        int highestIndexA = triStart - 1;
        int countA = 0;
        for (int triIndex = triStart; triIndex < triStart + totTris; triIndex++)
        {
            float3 pos = GetMidPos(components[triIndex].Cast<Tri2>());
            if ((axis == 0 && pos.x < splitCoord.x) ||
                (axis == 1 && pos.y < splitCoord.y) ||
                (axis == 2 && pos.z < splitCoord.z))
            {
                highestIndexA++;
                countA++;
                if (highestIndexA != triIndex)
                {
                    SwapPair(ref components, highestIndexA, triIndex);
                }
            }
        }

        return countA;
    }

    private (List<T>, List<T>) DivideIntoSubGroupsCopy<T>(T[] components, int axis, float3 splitCoord, int triStart, int totTris)
    {
        List<T> componentsChildA = new List<T>();
        List<T> componentsChildB = new List<T>();

        for (int triIndex = triStart; triIndex < triStart + totTris; triIndex++)
        {
            float3 pos = components[triIndex].mid;
            if ((axis == 0 && pos.x < splitCoord.x) ||
                (axis == 1 && pos.y < splitCoord.y) ||
                (axis == 2 && pos.z < splitCoord.z))
            {
                componentsChildA.Add(components[triIndex]);
            }
            else
            {
                componentsChildB.Add(components[triIndex]);
            }
        }

        return (componentsChildA, componentsChildB);
    }

    private int RecursivelySplitBV<T>(ref List<BV> BVs, ref T[] components, int bvParentIndex, BV bvParent, int depth = 0)
    {
        depth += 1;
        if (depth >= MaxDepthBVH) { BVs[bvParentIndex].SetLeaf(); return bvParentIndex; }
        
        (float3 splitCoord, int axis, float cost) leastCostSplit = (0, -1, float.MaxValue);

        // Find the best split point for the parent BV
        float3 diff = bvParent.max - bvParent.min;
        for (int split = 0; split < SplitResolution; split++)
        {
            float3 splitCoord = bvParent.min + diff * (split+0.5f) / SplitResolution;

            for (int axis = 0; axis < 3; axis++)
            {
                // Test splitting the parent bounding box
                List<T> componentsChildA;
                List<T> componentsChildB;
                (componentsChildA, componentsChildB) = DivideIntoSubGroupsCopy(components, axis, splitCoord, bvParent.triStart, bvParent.totTris);

                // Calculate cost (total surface area) of the resulting box split
                float cost = GetCost(componentsChildA, componentsChildB);

                // Compare the resulting cost with the currently lowest split cost
                if (cost < leastCostSplit.cost) { leastCostSplit = (splitCoord, axis, cost); }
            }
        }

        // No valid split found (probably only 1 or 2 tris)
        if (leastCostSplit.axis == -1) { BVs[bvParentIndex].SetLeaf(); return bvParentIndex; }

        // Divide the bounding box using the best tried split
        int countA = DivideIntoSubGroupsRef(ref components, leastCostSplit.axis, leastCostSplit.splitCoord, bvParent.triStart, bvParent.totTris);

        // Get tris for either child
        List<T> componentsBestChildA = components.Skip(bvParent.triStart).Take(countA).ToList();
        List<T> componentsBestChildB = components.Skip(bvParent.triStart + countA).Take(bvParent.totTris - countA).ToList();

        // Recursively split child A
        int furthestChildIndex = bvParentIndex;
        if (componentsBestChildA.Count != 0)
        {
            int childIndexA = bvParentIndex + 1;
            BVs[bvParentIndex].childIndexA = childIndexA;
            BVs.Add(new BV(GetTri2Min(componentsBestChildA), GetTri2Max(componentsBestChildA), bvParent.triStart, componentsBestChildA.Count));
            DebugUtils.ChildIndexValidation(childIndexA, BVs.Count);
            furthestChildIndex = RecursivelySplitBV(ref BVs, ref tris, childIndexA, BVs[childIndexA], depth);
        }

        // Recursively split child B
        if (componentsBestChildB.Count != 0)
        {
            int childIndexB = furthestChildIndex + 1;
            BVs[bvParentIndex].childIndexB = childIndexB;
            BVs.Add(new BV(GetTri2Min(componentsBestChildB), GetTri2Max(componentsBestChildB), bvParent.triStart + componentsBestChildA.Count, componentsBestChildB.Count));
            DebugUtils.ChildIndexValidation(childIndexB, BVs.Count);
            furthestChildIndex = RecursivelySplitBV(ref BVs, ref tris, childIndexB, BVs[childIndexB], depth);
        }

        // Return the currently furthest child index
        return furthestChildIndex;
    }

    private (int, int) ConstructBVHFromObj(ref BoundingVolume[] boundingVolumes, ref Tri[] tris, Mesh mesh)
    {
        Tri2[] newTris = LoadOBJ(mesh);

        float3 min = GetTri2Min(newTris);
        float3 max = GetTri2Max(newTris);
        List<BV> newBVs = new List<BV>
        {
            // First BV
            new BV(min, max, 0, newTris.Length, 1, 2)
        };

        // Construct the BVH
        Stopwatch stopwatch = Stopwatch.StartNew();
        RecursivelySplitBV(ref newBVs, ref newTris, 0, newBVs[0]);
        for (int i = 0; i < newBVs.Count; i++)
        {
            if (newBVs[i].childIndexA != -1) newBVs[i].childIndexA += boundingVolumes.Length;
            if (newBVs[i].childIndexB != -1) newBVs[i].childIndexB += boundingVolumes.Length;
            newBVs[i].triStart += tris.Length;
        }
        DebugUtils.LogStopWatch("BVH construction", ref stopwatch);

        // Convert to bounding volume struct variant for shader buffer transfer
        BoundingVolume[] newBoundingVolumes = BV.ClassToStruct(newBVs);

        // Add new bounding volumes & tris to existing arrays
        tris = tris.Concat(Utils.TrisFromTri2s(newTris)).ToArray();
        boundingVolumes = boundingVolumes.Concat(newBoundingVolumes).ToArray();

        return (newBoundingVolumes.Length, newTris.Length);
    }

    public (BoundingVolume[], Tri[], SceneObjectData[]) CreateSceneObjects()
    {
        sceneObjectsData ??= new SceneObjectData[sceneObjects.Length];

        // Create all scene objects
        for (int i = 0; i < sceneObjects.Length; i++)
        {
            // Retrieve relevant game object data
            GameObject sceneObject = sceneObjects[i];
            Transform transform = sceneObject.transform;
            SceneObjectSettings sceneObjectSettings = sceneObject.GetComponentInChildren<SceneObjectSettings>();
            Mesh mesh = sceneObject.GetComponentInChildren<MeshFilter>().mesh;

            SceneObjectData sceneObjectData = new SceneObjectData();

            // Set transformation matrices
            sceneObjectData.worldToLocalMatrix = Utils.CreateWorldToLocalMatrix(transform.position, transform.rotation.eulerAngles, transform.localScale);
            sceneObjectData.localToWorldMatrix = sceneObjectData.worldToLocalMatrix.inverse;

            // Set material key
            sceneObjectData.materialKey = sceneObjectSettings.MaterialKey;

            // Get mesh index
            int meshIndex = Utils.GetMeshIndex(LoadedMeshes, mesh);
            if (meshIndex == -1)
            {
                // Load mesh (construct it's BVH) if it has not yet been loaded
                LoadedMeshes.Add(new(mesh, loadedTris.Length, loadedBoundingVolumes.Length));
                ConstructBVHFromObj(ref loadedBoundingVolumes, ref loadedTris, mesh);
                meshIndex = LoadedMeshes.Count - 1;
            }

            // Set start index values
            sceneObjectData.triStartIndex = LoadedMeshes[meshIndex].triStartIndex;
            sceneObjectData.bvStartIndex = LoadedMeshes[meshIndex].bvStartIndex;

            // Add scene object data to the array
            sceneObjectsData[i] = sceneObjectData;
        }

        return (loadedBoundingVolumes, loadedTris, sceneObjectsData);
    }
}

--- SAVE 2 (SHADER):

HitInfo GetRayCollision (Ray ray, inout DebugData debugData)
{
    HitInfo hitInfo = InitHitInfo();

    for (int sceneObjectIndex = 0; sceneObjectIndex < SceneObjectsNum; sceneObjectIndex++)
    {
        SceneObject sceneObject = SceneObjects[sceneObjectIndex];

        Ray localRay;
        localRay.pos = mul(sceneObject.worldToLocalMatrix, float4(ray.pos, 1)).xyz;
        localRay.dir = mul(sceneObject.worldToLocalMatrix, float4(ray.dir, 0)).xyz;
        // localRay.invDir = 1 / localRay.dir; (optimisation to add)

        HitInfo localHitInfo = InitHitInfo();

        if (IterationSettings.z) TraverseTrisBVH(localHitInfo, debugData, localRay, sceneObject.bvStartIndex);

        if (localHitInfo.dst < hitInfo.dst)
        {
            hitInfo.didHit = true;
            hitInfo.dst = localHitInfo.dst;
            hitInfo.normal = normalize(mul(sceneObject.localToWorldMatrix, float4(localHitInfo.normal, 0)).xyz);
            hitInfo.hitPoint = ray.pos + ray.dir * hitInfo.dst;
            hitInfo.materialKey = sceneObject.materialKey;
        }
    }



    
    if (IterationSettings.x) IterateSpheres(hitInfo, ray);
    if (IterationSettings.w) IterateTris(hitInfo, ray);
    if (IterationSettings.y) IterateBVs(hitInfo, ray);

    return hitInfo;
}


uint GetRayIndex(uint2 threadIndex, uint rayIndex)
{
    uint rayIndex = (Resolution.x * threadIndex.y + threadIndex.x) * RaysPerPixel + rayIndex;
    return rayIndex;
}

// --- Outdated renderer functions ---

// Iterate functions do not utilize the BVH system, and can thereby be very slow to execute
void IterateSpheres(inout HitInfo hitInfo, Ray ray)
{
    for (int i = 0; i < SpheresNum; i++)
    {
        Sphere sphere = Spheres[i];
        // From the equation: sqrLength(rayPos + rayDir * dst) = radius^2
        // Solving for dst results in a quadratic equation with coefficients:
        float3 oc = ray.pos - sphere.pos;
        float a = dot(ray.dir, ray.dir);
        float b = 2.0 * dot(oc, ray.dir);
        float c = dot(oc, oc) - sqr(sphere.radius);
        float discriminant = b * b - 4.0 * a * c;

        // Validate ray-sphere hit
        if (discriminant > 0)
        {
            float dst = (-b - sqrt(discriminant)) / (2.0 * a);
            float3 hitPoint = ray.pos + dst * ray.dir;

            // Only render the object in front
            // Also only render ray hits in the positive ray direction
            if (dst < hitInfo.dst && 0 <= dst)
            {
                hitInfo.dst = dst;
                hitInfo.hitPoint = hitPoint;
                hitInfo.normal = normalize(hitInfo.hitPoint - sphere.pos); // The tangent is always the same as the sphere radius direction
                hitInfo.materialKey = sphere.materialKey;
            }
        }
    }
}
void IterateTris(inout HitInfo hitInfo, Ray ray)
{
    for (int i = 0; i < TrisNum; i++)
    {
        Tri tri = Tris[i];

        TriHitInfo triHitInfo = RayTriangleIntersect(ray, tri);
        
        if (triHitInfo.didHit)
        { 
            if (triHitInfo.dst < hitInfo.dst)
            {
                hitInfo.dst = triHitInfo.dst;
                hitInfo.materialKey = 0;
                hitInfo.normal = tri.worldNormal;
            }
        }
    }
}
void IterateBVs(inout HitInfo hitInfo, Ray ray)
{
    for (int i = 0; i < BVsNum; i++)
    {
        BoundingVolume bv = BVs[i];

        if (bv.min.x >= 1.#INF) continue;

        float dst = RayBVIntersect(ray, bv);
        
        if (dst < hitInfo.dst)
        {
            hitInfo.dst = dst;
            hitInfo.materialKey = 1; // BVs do not have materials
        }
    }
}
































#pragma kernel GenerateCandidatesDL // 0
#pragma kernel TraceRays // 1
#pragma kernel SpatialReusePass // 2

#include "RendererResources.hlsl"

// Constants
const uint TrisNum;
const uint BVsNum;
const uint MaxBVHDepth;
const uint SceneBVHStartIndex;
const uint SceneObjectsNum;
const float ScatterProbability;

// Render quality settings
const uint MaxBounceCount;
const uint RaysPerPixel; // Currectly always set to 1

// View settings
const int2 Resolution;
const float2 ViewSpaceDims;
const float DefocusStrength;
const float FocalPlaneFactor;

// Camera orientation and transform
const float3 WorldSpaceCameraPos;
const float3x3 CameraTransform;

// Per frame
const uint FrameRand; // "random" value from 0 to 999999, gets reset each frame
const uint FrameCount; // Each frame: FrameCount++
const uint UseExistingCandidates; // 1 == true, 0 == false

// Debug
const int2 DebugDataMaxValues;

// Temp tex.
const uint2 TexDims;

// ReSTIR - Reservoir sample quality
const uint SceneObjectReservoirTestsNum;
const uint TriReservoirTestsNum;

// ReSTIR - Other
const uint EmittingObjectsNum;
const float TotArea;

RWStructuredBuffer<HitInfo> HitInfos;
RWStructuredBuffer<float4> Candidates; // float4(dir, weight)

StructuredBuffer<Tri> Tris;
StructuredBuffer<BoundingVolume> BVs;
StructuredBuffer<SceneObject> SceneObjects;
StructuredBuffer<LightObject> LightObjects;
StructuredBuffer<Material2> Materials;

Texture2D<float4> TestTexture;

// Output textures
RWTexture2D<float4> Result;
RWTexture2D<float4> DebugOverlay;
RWTexture2D<float4> RayHitPoints;

float3 ApplyCameraTransform(float3 point2)
{
    return mul(CameraTransform, point2);
}

float TriDstSqr(float3 p, float3 a, float3 b, float3 c )
{
  float3 ba = b - a; float3 pa = p - a;
  float3 cb = c - b; float3 pb = p - b;
  float3 ac = a - c; float3 pc = p - c;
  float3 nor = cross( ba, ac );

  return (sign(dot(cross(ba,nor),pa)) +
         sign(dot(cross(cb,nor),pb)) +
         sign(dot(cross(ac,nor),pc))<2.0)
         ?
         min( min(
         dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),
         dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),
         dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )
         :
         dot(nor,pa)*dot(nor,pa)/dot2(nor);
}

TriHitInfo RayTriangleIntersect(Ray ray, Tri tri)
{
    float3 edgeAB = tri.vB - tri.vA;
    float3 edgeAC = tri.vC - tri.vA;
    float3 normalVector = cross(edgeAB, edgeAC);
    float3 ao = ray.pos - tri.vA;
    float3 dao = cross(ao, ray.dir);

    float determinant = -dot(ray.dir, normalVector);
    float invDet = 1 / determinant;

    // Calculate dst to triangle & barycentric coordinates of intersection point
    float dst = dot(ao, normalVector) * invDet;
    float u = dot(edgeAC, dao) * invDet;
    float v = -dot(edgeAB, dao) * invDet;
    float w = 1 - u - v;

    // Initialize tri hit info
    TriHitInfo triHitInfo;
    triHitInfo.didHit = determinant >= 1E-8 && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
    triHitInfo.uv = triHitInfo.didHit ? tri.uvA * w + tri.uvB * u + tri.uvC * v : float2(0, 0);
    triHitInfo.dst = dst;
    return triHitInfo;
}

float RayBVIntersect(Ray ray, BoundingVolume bv)
{
    float3 tMin = (bv.min - ray.pos) / ray.dir;
    float3 tMax = (bv.max - ray.pos) / ray.dir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    bool didHit = tFar >= tNear && tFar > 0;
    float dst = didHit ? tNear > 0 ? tNear : 0 : 1.#INF;

    return dst;
};

void TraverseTrisBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray, uint bvStartIndex)
{
    uint bvStack[MAX_BVH_DEPTH + 1];
    uint stackPointer = 0;
    bvStack[stackPointer++] = bvStartIndex;

    while (stackPointer > 0)
    {
        BoundingVolume bv = BVs[bvStack[--stackPointer]];

        bool isLeaf = bv.indexA >= 0;
        bv.indexA = abs(bv.indexA);
        bv.indexB = abs(bv.indexB);
        
        if (isLeaf)
        {
            for (int triIndex = bv.indexA; triIndex < bv.indexA + bv.indexB; triIndex++)
            {
                Tri tri = Tris[triIndex];
                TriHitInfo triHitInfo = RayTriangleIntersect(ray, tri); debugData.triChecks++;
                
                if (triHitInfo.didHit && triHitInfo.dst < hitInfo.dst)
                {
                    hitInfo.dst = triHitInfo.dst;
                    hitInfo.uv = triHitInfo.uv;
                    hitInfo.normal = tri.worldNormal;
                }
            }
        }
        else
        {
            // Check child BV intersections
            BoundingVolume bvA = BVs[bv.indexA];
            float dstA = RayBVIntersect(ray, bvA); debugData.bvChecks++;
            BoundingVolume bvB = BVs[bv.indexB];
            float dstB = RayBVIntersect(ray, bvB); debugData.bvChecks++;

            // Push the nearest BV last, to avaluate it first
            if (dstA < dstB)
            {
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
            }
            else
            {
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
            }
        }
    }
}

void TraverseSceneBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray)
{
    uint bvStack[MAX_BVH_DEPTH + 1];
    uint stackPointer = 0;
    bvStack[stackPointer++] = SceneBVHStartIndex;

    while (stackPointer > 0)
    {
        BoundingVolume bv = BVs[bvStack[--stackPointer]];

        bool isLeaf = bv.indexA >= 0;
        bv.indexA = abs(bv.indexA);
        bv.indexB = abs(bv.indexB);
        
        if (isLeaf)
        {
            for (int sceneObjectIndex = bv.indexA; sceneObjectIndex < bv.indexA + bv.indexB; sceneObjectIndex++)
            {
                SceneObject sceneObject = SceneObjects[sceneObjectIndex];

                Ray localRay;
                localRay.pos = mul(sceneObject.worldToLocalMatrix, float4(ray.pos, 1)).xyz;
                localRay.dir = mul(sceneObject.worldToLocalMatrix, float4(ray.dir, 0)).xyz;
                // localRay.invDir = 1 / localRay.dir; (optimisation to add)
        
                HitInfo localHitInfo = InitHitInfo();
        
                TraverseTrisBVH(localHitInfo, debugData, localRay, sceneObject.bvStartIndex);
        
                if (localHitInfo.dst < hitInfo.dst)
                {
                    hitInfo.dst = localHitInfo.dst;
                    hitInfo.normal = localHitInfo.normal;
                    hitInfo.hitPoint = ray.pos + ray.dir * hitInfo.dst;
                    hitInfo.uv = localHitInfo.uv;
                    hitInfo.materialIndex = sceneObject.materialIndex;
                }
            }
        }
        else
        {
            // Check child BV intersections
            BoundingVolume bvA = BVs[bv.indexA];
            float dstA = RayBVIntersect(ray, bvA); debugData.bvChecks++;
            BoundingVolume bvB = BVs[bv.indexB];
            float dstB = RayBVIntersect(ray, bvB); debugData.bvChecks++;

            // Push the nearest BV last, to avaluate it first
            if (dstA < dstB)
            {
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
            }
            else
            {
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
            }
        }
    }
}

HitInfo GetRayCollision (Ray ray, inout DebugData debugData)
{
    HitInfo hitInfo = InitHitInfo();

    TraverseSceneBVH(hitInfo, debugData, ray);

    return hitInfo;
}

float3 SampleTexColor(float2 uv)
{
    float2 texCoords = int2(uv * TexDims);

    int2 iTexCoords = int2(texCoords);
    float2 fTexCoords = frac(texCoords);

    int2 texel00 = iTexCoords % TexDims;
    int2 texel10 = (iTexCoords + int2(1, 0)) % TexDims;
    int2 texel01 = (iTexCoords + int2(0, 1)) % TexDims;
    int2 texel11 = (iTexCoords + int2(1, 1)) % TexDims;

    float4 col00 = TestTexture[texel00];
    float4 col10 = TestTexture[texel10];
    float4 col01 = TestTexture[texel01];
    float4 col11 = TestTexture[texel11];

    float4 col0 = lerp(col00, col10, fTexCoords.x);
    float4 col1 = lerp(col01, col11, fTexCoords.x);
    float4 col = lerp(col0, col1, fTexCoords.y);

    return col.xyz;
}

int LightObjectReservoirSample(inout uint state)
{
    int firstIndex = randIntSpan(0, EmittingObjectsNum, state); // 1 -> EmittingObjectsNum
    float firstWeight = LightObjects[firstIndex].areaApprox;
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);

    for (uint i = 0; i < SceneObjectReservoirTestsNum; i++)
    {
        int candidateIndex = randIntSpan(0, EmittingObjectsNum, state); // 1 -> EmittingObjectsNum
        float candidateWeight = LightObjects[candidateIndex].areaApprox;

        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }

    return reservoir.chosenIndex;
}

int TriReservoirSample(uint startTriIndex, uint endTriIndex, inout uint state)
{
    int firstIndex = randIntSpan(startTriIndex, endTriIndex, state);
    float firstWeight = GetTriArea(Tris[firstIndex]);
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);

    for (uint i = 0; i < TriReservoirTestsNum; i++)
    {
        int candidateIndex = randIntSpan(startTriIndex, endTriIndex, state);
        float candidateWeight = GetTriArea(Tris[candidateIndex]);

        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }

    return reservoir.chosenIndex;
}

// For now, BSDFs won't be considered
float GetBRDF() { return 1; }

float GenerateCandidateWeight(float sqrDst, float hitAngleDot, float brightness)
{
    return GetBRDF() * brightness * hitAngleDot / sqrDst;
}

void GenerateCandidatesDL2(float3 hitNormal, float3 pos, uint pixelIndex, inout uint state)
{
    for (uint i = 0; i < RaysPerPixel; i++)
    {
        // Weighted light object Sample
        uint lightObjectIndex = LightObjectReservoirSample(state);
        LightObject lightObject = LightObjects[lightObjectIndex];
        uint startTriIndex = lightObject.triStart;
        uint endTriIndex = lightObject.triStart + lightObject.totTris;

        // Weighted tri Sample
        uint triIndex = TriReservoirSample(startTriIndex, endTriIndex, state);
        Tri tri = Tris[triIndex];
        float3 worldPoint = GetRandWorldPointTri(tri, lightObject.localToWorldMatrix, state);

        float3 dst = worldPoint - pos;
        float3 dir = normalize(dst);

        uint candidateIndex = pixelIndex * RaysPerPixel + i;
        
        // Validate direction
        if (dot(hitNormal, dir) < 0)
        {
            // If direction is invalid, abandon the current candidate
            Candidates[candidateIndex] = float4(0, 0, 0, 0);
            continue;
        }

        float hitAngleDot = max(dot(tri.worldNormal, dir), 0);
        
        Candidates[candidateIndex] = float4(dir, GenerateCandidateWeight(dot2(dst), hitAngleDot, lightObject.brightness));
    }
}

uint GetPixelIndex(uint2 threadID)
{
    uint rayBaseIndex = (Resolution.x * threadID.y + threadID.x) * RaysPerPixel;
    return rayBaseIndex;
}

[numthreads(TN_RT,TN_RT,1)]
void GenerateCandidatesDL (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    DebugData debugData = InitDebugData();
    uint state = id.y * Resolution.x + id.x + FrameRand;

    // Calculate focal plane world pos for the given pixel
    float focalPosX = (float(id.x) / Resolution.x - 0.5) * 2.0 * ViewSpaceDims.x;
    float focalPosY = (float(id.y) / Resolution.y - 0.5) * 2.0 * ViewSpaceDims.y;
    float3 focalPos = float3(focalPosX, focalPosY, 1) * FocalPlaneFactor;
    float3 worldFocalPos = ApplyCameraTransform(focalPos) + WorldSpaceCameraPos;

    // Trace ray(s) through the scene
    uint pixelIndex = GetPixelIndex(id.xy);
    TraceInfo combinedTraceInfo;

    // Ray setup
    Ray ray;
    ray.pos = WorldSpaceCameraPos;
    ray.dir = normalize(worldFocalPos - ray.pos);

    // Cast first ray
    HitInfo hitInfo = GetRayCollision(ray, debugData);
    bool didHit = hitInfo.dst != 1.#INF;

    // Use ReStir to generate ray bounce direction candidates
    if (didHit && !UseExistingCandidates) GenerateCandidatesDL2(hitInfo.normal, hitInfo.hitPoint, pixelIndex, state);

    // Save ray hit info data
    HitInfos[pixelIndex] = hitInfo;

    // Store hit point data for debug purposes
    float3 firstHit = didHit ? hitInfo.hitPoint : float3(0, 0, 0);
    RayHitPoints[id.xy] = float4(firstHit, 0);

    // Record debug data
    bool badMaxBVHDepth = MaxBVHDepth >= MAX_BVH_DEPTH;
    DebugOverlay[id.xy] = float4(debugData.triChecks / (float)DebugDataMaxValues.x, debugData.bvChecks / (float)DebugDataMaxValues.y, badMaxBVHDepth, 0);
}

// --- Kernel "TraceRays": ---

void UpdateCandidateWeight(float brightness, uint candidateIndex)
{
    bool validCandidate = brightness > 0;
    float correctionWeight = validCandidate ? 1.#INF: 1.#INF;

    // Candidate weight should also be modified according to the hit light (light * hitAngleDot * ...) ! ! !

    // The candiate is invalid if the ray hit an unlit object after the first bounce

    return;
}

TraceInfo Trace(Ray ray, HitInfo hitInfo, uint candidateIndex, inout DebugData debugData, inout uint state)
{
    TraceInfo traceInfo;
    traceInfo.rayColor = float3(1, 1, 1);
    traceInfo.incomingLight = float3(0, 0, 0);

    for (uint bounceCount = 0; bounceCount <= MaxBounceCount; bounceCount++) // MaxBounceCount = 1 for direct lighting 
    {
        if (hitInfo.dst == 1.#INF) break;

        bool didHit = hitInfo.dst != 1.#INF;
        
        // Material2 material = didHit ? Materials[hitInfo.materialIndex] : InitMaterial();
        Material2 material = InitMaterial();
        if (didHit) { material = Materials[hitInfo.materialIndex]; }

        // Candidate validation
        // UpdateCandidateWeight(float brightness, uint candidateIndex) ! ! !
        bool validCandidate = bounceCount != 1 || material.brightness <= 0;
        if (!validCandidate)
        {
            Candidates[candidateIndex] = float4(0, 0, 0, 0);
        }

        // Calculate new ray pos
        ray.pos = hitInfo.hitPoint - hitInfo.normal * 0.001; // epsilon offset

        // Ray direction already decided for first bounce!
        bool isSpecularBounce = false;
        if (bounceCount != 0)
        {
            // Calculate new ray direction
            // isSpecularBounce == False -> ray.dir = scatterDir
            // isSpecularBounce == True -> ray.dir = norm(lerp(scatterDir, specularDir, material.smoothness))
            isSpecularBounce = ScatterProbability < randNormalized(state);
            // Cosine weighted randPointOnUnitSphere. This removes the need for any "light spread" calculations
            float3 scatterDir = normalize(hitInfo.normal + randPointOnUnitSphere(state));
            float3 specularDir = reflect(ray.dir, hitInfo.normal);
            ray.dir = normalize(lerp(scatterDir, specularDir, material.smoothness * isSpecularBounce));

            // Validate ray direction
            if (dot(hitInfo.normal, ray.dir) < 0)
            {
                ray.dir = -ray.dir;
            }
        }

        // Calculate new traceInfo values
        float3 sampleCol = material.color; // /SampleTexColor(hitInfo.uv)
        float3 emittedLight = sampleCol * material.brightness / sqr(hitInfo.dst);
        traceInfo.incomingLight += emittedLight * traceInfo.rayColor;
        traceInfo.rayColor *= lerp(material.color, material.specularColor, isSpecularBounce);

        // Evaluate the amount of light contributed by the candidate and update it's weight accordingly (linear relationship)
        if (bounceCount == 1) UpdateCandidateWeight(material.brightness, candidateIndex); 

        // Recast ray
        if (bounceCount != MaxBounceCount) hitInfo = GetRayCollision(ray, debugData);
    }

    return traceInfo;
}

[numthreads(TN_RT,TN_RT,1)]
void TraceRays (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    DebugData debugData = InitDebugData(); // Debug data never gets recorded for this kernel
    uint state = id.y * Resolution.x + id.x + FrameRand;

    uint pixelIndex = GetPixelIndex(id.xy); // removed "+ i" to prevent issues if RaysPerPixel != 1

    TraceInfo combinedTraceInfo;

    // Retrieve stored hitInfo data
    HitInfo hitInfo = HitInfos[id.y * Resolution.x + id.x];

    // Trace each ray through the scene
    for (uint rayIndex = 0; rayIndex < RaysPerPixel; rayIndex++)
    {
        // Get a ray direction from the current candidates
        uint candidateIndex = pixelIndex * RaysPerPixel + rayIndex;
        float4 RISData = Candidates[candidateIndex];

        // Return no color if initial ray trace missed
        if (hitInfo.dst == 1.#INF)
        {
            Result[id.xy] = float4(0, 0, 0, 0);
            return;
        }
        // Return the emitted light of the first hit object if no further ray direction candidates are found
        else if (all(RISData.xyz) == 0)
        {
            Material2 material = Materials[hitInfo.materialIndex];
    
            // Calculate new traceInfo values
            float3 sampleCol = material.color; // /SampleTexColor(hitInfo.uv)
            float3 emittedLight = sampleCol * material.brightness / sqr(hitInfo.dst);
            float3 col = emittedLight;
    
            Result[id.xy] = float4(col, 0);
            return;
        }

        // Ray setup
        Ray ray;
        ray.pos = hitInfo.hitPoint;
        ray.dir = RISData.xyz;

        // Trace ray
        TraceInfo traceInfo = Trace(ray, hitInfo, candidateIndex, debugData, state);

        // Record traceInfo
        float correctionWeight = RISData.w;
        combinedTraceInfo.incomingLight += traceInfo.incomingLight * correctionWeight;
    }
    combinedTraceInfo.incomingLight /= RaysPerPixel;

    float3 col = combinedTraceInfo.incomingLight;

    // Record ray tracer result
    Result[id.xy] = float4(col, 0);
}

[numthreads(TN_RT,TN_RT,1)]
void SpatialReusePass (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    uint state = id.y * Resolution.x + id.x + FrameRand;

    // Trace ray(s) through the scene
    uint pixelIndex = GetPixelIndex(id.xy); // removed "+ i" to prevent issues if RaysPerPixel != 1
    uint candidateBaseIndex = pixelIndex * RaysPerPixel;
}